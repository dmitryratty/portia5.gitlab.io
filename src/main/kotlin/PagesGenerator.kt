import java.util.*
import kotlin.collections.ArrayList
import kotlin.io.path.*
import kotlin.text.StringBuilder

class PagesGenerator(
    /**
     * https://stackoverflow.com/questions/1946426/html-5-is-it-br-br-or-br
     */
    val xhmtlCompatibleVoidElements: Boolean = false
) {
    companion object {
        @JvmStatic
        fun main(args: Array<String>) {
            PagesGenerator().main()
        }
    }
    val hostName = "https://dmitryratty.gitlab.io"
    private val wbrElement = if (xhmtlCompatibleVoidElements) "<wbr/>" else "<wbr>"
    private val brElement = if (xhmtlCompatibleVoidElements) "<br/>" else "<br>"
    private val maxUnwrappedWordLenght = 25
    // "<span class=\"nowrap\">$1</span>"
    private val dashNoWrap = "(\\S+-\\S+)".toRegex()
    // "<a href=\"$1\">\$1</a>"
    private val hyperlink = "(http\\S+)".toRegex()
    val footnote = "(\\S+\\[\\d+])".toRegex()
    private val wbrBefore = "([/~.,\\-_?#%])".toRegex()
    private val wbrAfter = "([:])".toRegex()
    private val wbrBeforeAfter = "([=&])".toRegex()
    private val resourcesDir = Utils().resourcesDir
    private val htmlTemplate get() = resourcesDir.resolve("page-template.html").toFile().readText()
    private val lineTransformer = LineTransformer(true, LineTransformer().simpleSpacesTransformer)
    private val setOfLinks = sortedSetOf<String>()
    private val setOfLongWords = sortedSetOf<String>()

    data class Page(val path: String, val raw: String) {
        var includedReady = false
        var includedShortText: String? = null
        lateinit var includedText: String
        lateinit var beautyfiedText: String
        val bottomNavigation = path != "index.txt"
        var _title: String? = null
        val title: String
            get() {
                initializeTitle()
                return _title ?: throw IllegalStateException()
            }

        private fun initializeTitle() {
            if (_title != null) {
                return
            }
            if (path == "index.txt") {
                _title = "Well‚Ä¶ Yes!"
            } else if (path.endsWith("/index.txt")) {
                var name = path.substring(0, path.length - "/index.txt".length)
                if (name.contains('/')) {
                    _title = "Well‚Ä¶ \"$name\"!"
                } else {
                    name = name.replaceFirstChar {
                        if (it.isLowerCase()) it.titlecase(Locale.ENGLISH) else it.toString()
                    }
                    _title = "Well‚Ä¶ $name!"
                }
            } else {
                var name = path.substring(0, path.length - ".txt".length)
                if (name.contains('/')) {
                    _title = "Well‚Ä¶ \"$name\"!"
                } else {
                    name = name.replaceFirstChar {
                        if (it.isLowerCase()) it.titlecase(Locale.ENGLISH) else it.toString()
                    }
                    _title = "Well‚Ä¶ $name!"
                }
            }
        }
    }

    fun main() {
        Library().main()
        generateMap()
        TextFormatter().main()
        val pages = Utils().textPagesInput().entries.associate {
            it.key.pathString to Page(it.key.pathString, it.value.readText())
        }
        pages.forEach {
            val page = it.value
            includesResolver(pages, page)
            page.beautyfiedText = TextBeautifier().transform(page.includedText)
            val bodyHtml = textToHtml(page.path, page.beautyfiedText)
            val htmlFile = Utils().textPageInputToHtmlOutputFile(page.path)
            htmlFile.parentFile.mkdirs()
            htmlFile.writeText(htmlPage(page.title, bodyHtml, page.bottomNavigation))
        }
        Utils().testAutogeneratedDir.resolve("links-list.txt").toFile()
            .writeText(setOfLinks.joinToString("\n"))
        Utils().testAutogeneratedDir.resolve("long-words-list.txt").toFile()
            .writeText(setOfLongWords.joinToString("\n"))
    }

    private val includeTag = "#include "
    private val includeShortTag = "#include-short "
    private val includeShortLink = "- #include-short-link"

    private fun includesResolver(pages: Map<String, Page>, page: Page) {
        val includesResolved = StringBuilder()
        page.raw.split('\n').forEach { line ->
            if (line == includeShortLink) {
                page.includedShortText = includesResolved.toString()
                var path = page.path
                path = if (path.endsWith("/index.txt")) {
                    path.removeSuffix("/index.txt")
                } else {
                    path.removeSuffix(".txt")
                }
                page.includedShortText += "\n - ${hostName}/${path}"
                return@forEach
            } else if (line.startsWith(includeTag)) {
                val path = line.substring(includeTag.length, line.length)
                val includedPage = pages[path]
                if (!includedPage!!.includedReady) {
                    includesResolver(pages, includedPage)
                }
                includesResolved.append('\n').append(includedPage.includedText)
            } else if (line.startsWith(includeShortTag)) {
                var path = line.substring(includeShortTag.length, line.length)
                val include = Utils().pagesSrcDir.resolve(path)
                path += if (include.isDirectory()) {
                    "/index.txt"
                } else {
                    ".txt"
                }
                val includedPage = pages[path]
                if (!includedPage!!.includedReady) {
                    includesResolver(pages, includedPage)
                }
                if (includedPage.includedShortText == null) throw IllegalStateException(path)
                includesResolved.append('\n').append(includedPage.includedShortText)
            } else {
                includesResolved.append('\n').append(line)
            }
        }
        page.includedText = includesResolved.toString()
        page.includedReady = true
    }

    private fun stripEnding(path: String): String {
        return if (path == "index.txt") {
            ""
        } else if (path.endsWith("/index.txt")) {
            path.substring(0, path.length - "/index.txt".length)
        } else {
            path.substring(0, path.length - ".txt".length)
        }
    }

    private fun generateMap() {
        val pagesListLayerOne = ArrayList<String>()
        val pagesListLayerTwo = ArrayList<String>()
        val prefix = hostName
        Utils().textPagesInput().forEach {
            val path = stripEnding(it.key.pathString)
            if (path.startsWith("other/")) {
                pagesListLayerTwo.add("$prefix/$path")
            } else {
                if (path == "") {
                    pagesListLayerOne.add(prefix)
                } else {
                    pagesListLayerOne.add("$prefix/$path")
                }
            }
        }
        val mapPath = "other/map"
        if (!pagesListLayerTwo.contains("$prefix/$mapPath")) {
            pagesListLayerTwo.add("$prefix/$mapPath")
        }
        val map = StringBuilder()
        map.append("Map.")
        if (true) {
            pagesListLayerOne.addAll(pagesListLayerTwo)
            pagesListLayerOne.sort()
            pagesListLayerOne.forEach { map.append('\n').append(it) }
        } else {
            pagesListLayerOne.sort()
            pagesListLayerOne.forEach { map.append('\n').append(it) }
            pagesListLayerTwo.sort()
            pagesListLayerTwo.forEach { map.append('\n').append(it) }
        }
        Utils().pagesSrcDir.resolve("$mapPath.txt").toFile().writeText(map.toString())
    }

    private val bottomNavigationHtml = "\n    <p class=\"dinkus\">* * *</p>" +
            "\n\n    <p>üè† <a href=\"/\">$hostName</a></p>"

    fun htmlPage(title: String, body: String, bottomNavigation: Boolean): String {
        return htmlTemplate
            .replace("<!--TITLE-->", title)
            .replace("<!--DATA-->", "    $body")
            .replace("<!--DATA-FOOTER-->", if (bottomNavigation) bottomNavigationHtml else "")
    }

    private fun makeNoWrap(word: String): String {
        return "<span class=\"nowrap\">$word</span>"
    }

    private fun longUrlLineBreaks(url: String): String {
        // https://css-tricks.com/better-line-breaks-for-long-urls/
        val newUrl = url.split("//").joinToString("//<wbr>") { part ->
            // Insert a word break opportunity after a colon
            part.replace(wbrAfter, "\$1<wbr>")
                // Before a single slash, tilde, period, comma, hyphen, underline,
                // question mark, number sign, or percent symbol.
                .replace(wbrBefore, "<wbr>\$1")
                // Before and after an equals sign or ampersand
                .replace(wbrBeforeAfter, "<wbr>\$1<wbr>")
        }
        return if (xhmtlCompatibleVoidElements) {
            newUrl.replace("<wbr>", "<wbr/>")
        } else {
            newUrl
        }
    }

    @Suppress("RegExpSimplifiable")
    private val longWordLineBreaks = "((.{$maxUnwrappedWordLenght})|(.+))".toRegex()

    fun longWordLineBreaksTwo(word: String): String {
        // TODO "&shy;" vs wbrElement
        return longWordLineBreaks.findAll(word).map { it.value }.joinToString(wbrElement)
    }

    fun longWordLineBreaks(word: String): String {
        val result = StringBuilder()
        word.split('-').forEach {
            if (result.isNotEmpty()) result.append('-')
            if (it.length > maxUnwrappedWordLenght) {
                setOfLongWords.add(word)
                result.append(longWordLineBreaksTwo(it))
            } else {
                result.append(it)
            }
        }
        return result.toString()
    }

    fun transformLink(link: String): String {
        setOfLinks.add(link)
        val linkDisplay = if (link.length > maxUnwrappedWordLenght) {
            longUrlLineBreaks(link)
        } else {
            link
        }
        if (link.startsWith(hostName)) {
            val relativeLink = if (link == hostName) "/" else link.removePrefix(hostName)
            return "<a href=\"$relativeLink\">$linkDisplay</a>"
        } else {
            return "<a href=\"$link\">$linkDisplay</a>"
        }
    }

    fun isIdeographic(word: String): Boolean {
        // TODO Character.isIdeographic(int codepoint)
        return word.contains("Êù±‰∫úÈáçÂ∑•")
    }

    fun transformWord(word: String): String {
        if (Utils().isHyperlink(word)) {
            return transformLink(word)
        }
        // Replace "‚Ä¶" with html entity?
        var newWord = word.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
            //.replace("\"", "&quot;").replace("'", "&apos;")
        if (newWord.length > maxUnwrappedWordLenght) {
            newWord = longWordLineBreaks(newWord)
        } else {
            if (newWord.contains('-')) {
                newWord = makeNoWrap(newWord)
            } else if (isIdeographic(newWord)) {
                newWord = makeNoWrap(newWord)
            } else if (footnote.matches(newWord)) {
                // Footnote inside text, like "world![2]". We make "world![2]"
                // no wrap, because by default "[2]" can be wrapped to the next line
                // from "world!".
                newWord = makeNoWrap(newWord)
            }
        }
        return newWord
    }

    fun transformLine(line: String): String {
        return lineTransformer.transform(line, ::transformWord)
    }

    fun transformParagraph(paragraph: String): String {
        val result = StringBuilder()
        if (paragraph.contains("* * *")) {
            if (paragraph != "* * *") {
                throw IllegalStateException(paragraph)
            }
            result.append("<p class=\"dinkus\">* * *</p>")
            return result.toString()
        }
        result.append("<p>")
        val lines = Utils().splitParagraphToLines(paragraph)
        result.append(lines.joinToString("\n        $brElement", transform = ::transformLine))
        result.append("</p>")
        return result.toString()
    }

    fun textToHtml(tag: String, text: String): String {
        val article = StringBuilder()
        Utils().splitToParagraphs(text).forEach { paragraph ->
            if (article.isNotEmpty()) {
                article.append("\n\n    ")
            }
            try {
                article.append(transformParagraph(paragraph))
            } catch (e: Exception) {
                throw IllegalStateException(tag, e)
            }
        }
        return article.toString()
    }
}